{
  "slots": {
    "0": {
      "name": "slot1",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "slot2",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "slot3",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "slot4",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "player",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "construct",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-4": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-5": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "ping()",
      "filter": {
        "args": [
          {
            "value": "ping"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "NestCo.update()",
      "filter": {
        "args": [
          {
            "value": "next"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "unit.stopTimer(\"clearPause\")\nclearPause()",
      "filter": {
        "args": [
          {
            "value": "clearPause"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "databank.clearValue(\"status:\" .. unit.getName())\n",
      "filter": {
        "args": [],
        "signature": "onStop()",
        "slotKey": "-1"
      },
      "key": "3"
    },
    {
      "code": "-- PB_CHEF_LINECOOK_Waitress.LUA\n---- (1) ----\nunit.hideWidget()\nchef_linecook_version = \"1.2.3f\"\n\nfunction adjustIndustryName(text)\n    text = text:lower()\n    local split = strSplit(text, \" \")\n    text = split[2]\n    for i = 3, 10 do\n        if split[i] == nil then split[i] = \"\" end\n        if split[i] == \"xs\" or split[i] == \"s\" or split[i] == \"m\" or split[i] == \"l\" or split[i] == \"xl\" then\n            return text .. \" \" .. split[i]\n        end\n    end\n    return text\nend\n\nfunction getStack(industryname)\n    local entryStack = newStack()\n    if isATransferUnit(industryname) then\n        local added = {}\n        for count = 1, 30 do\n            local ikey = \"needed\" .. count\n            if databank.hasKey(ikey) == 1 then\n                local itemid = databank.getStringValue(ikey)\n                if added[itemid] ~= true then\n                    system.print(\"adding need to stack: \" .. itemid)\n\n                    local item = requirements[mfloor(tonumber(itemid))]\n                    if item then\n                        entryStack.push(item)\n                        added[itemid] = true\n                    end\n                end\n            end\n            databank.clearValue(ikey)\n        end\n        if entryStack.size > 0 then return entryStack end\n    end\n\n    for id, item in pairs(requirements) do\n        local known = getKnown(item.id) -- do we already know this item's proper industry?\n\n        if isATransferUnit(industryname) or (known == \"\" or known == industryname) then\n            entryStack.push(item)\n        end\n    end\n    return shuffle(entryStack)\nend\n\nfunction checkForOverproducing(slot, info)\n    if info.state == IndustryStatus.running\n        or info.state == IndustryStatus.jammed then\n        local outputs = info.currentProducts\n        local itemId = outputs[1].id\n        local current = 0\n        local maintain = 0\n\n        if info.maintainProductAmount > 0 then\n            maintain = mceil(info.maintainProductAmount)\n        end\n\n        if itemId and requirements[itemId] and maintain > (maintainMultiplier * requirements[itemId].quantity) then\n            slot.stop(false, false)\n        elseif itemId == nil or requirements[itemId] == nil then\n            slot.stop(false, false)\n        end\n    end\nend\n\ncomplete = 0\nfunctions = {}\n\nfunctions.slot1 = function() doIndustry(slot1, functions.slot1) end\nfunctions.slot2 = function() doIndustry(slot2, functions.slot2) end\nfunctions.slot3 = function() doIndustry(slot3, functions.slot3) end\nfunctions.slot4 = function() doIndustry(slot4, functions.slot4) end\nfunctions.slot5 = function() doIndustry(slot5, functions.slot5) end\nfunctions.slot6 = function() doIndustry(slot6, functions.slot6) end\nfunctions.slot7 = function() doIndustry(slot7, functions.slot7) end\nfunctions.slot8 = function() doIndustry(slot8, functions.slot8) end\nfunctions.slot9 = function() doIndustry(slot9, functions.slot9) end\nfunctions.slot10 = function() doIndustry(slot10, functions.slot10) end\n\ncook_check = 0\nfunction doIndustry(slot, f)\n    if slot and slot.getLocalId and industries[slot.getLocalId()] then\n        local industry = industries[slot.getLocalId()]\n        local state = checkCooking(slot, industry, f)\n\n        cook_check = cook_check + 1\n        while cook_check < 10 do y(f) end -- wait for everyone do be done\n\n        if state ~= IndustryStatus.running then doBuild(slot, industry, f) end\n    else\n        cook_check = cook_check + 1\n    end\nend\n\nlocal stacks = {}\nlocal cooking = {}\nfunction checkCooking(slot, industry, f)\n    local industryname = industry.name\n\n    local info = slot.getInfo()\n    local state = info.state\n\n    if state == IndustryStatus.running then -- cooking something\n        outputs = slot.getOutputs()\n        if outputs and outputs[1] then\n            cooking[outputs[1].id] = true\n            --- system.print(industryname .. \" cooking \" .. getName(outputs[1].id))\n            if isATransferUnit(industryname) then setKnown(outputs[1].id, industry.name) end\n\n            -- make sure we're not cooking too many, sometimes a bug will put in way too many\n        end\n    end\n\n    checkForOverproducing(slot, info)\n    return state\nend\n\nfunction doBuild(slot, industry, f)\n    if industry == nil then return end\n\n    local slotId = slot.getLocalId()\n    local industryname = industry.name\n\n    local info = slot.getInfo()\n    local state = info.state\n    local skip = false\n\n    local stack\n    if stacks[industryname] == nil or stacks[industryname].size == 0 then\n        stacks[industryname] = getStack(industryname)\n    end\n    stack = stacks[industryname]\n\n    -- system.print(\"Checking industry for \" .. industryname .. \" with stack size \" .. stack.size .. \" state: \" .. state)\n\n    while state ~= IndustryStatus.running and skip == false and stack.size > 0 do\n        if state == IndustryStatus.no_schemas\n            or state == IndustryStatus.running then\n            skip = true\n        end\n        if state == IndustryStatus.jammed\n            and industryname == \"refiner m\" then\n            skip = true\n        end\n        if state == IndustryStatus.running\n            and isATransferUnit(industryname) then\n            skip = true\n        end                                                                -- do not interfere with large transfers industry\n\n        if skip then\n            system.print(\">>> Skipping \" .. industryname .. \" with state \" .. state)\n            return\n        end\n\n        local item = stack.pop()\n        if item ~= nil then\n            system.print(\"+++ checking \" .. industryname .. \" with state \" .. state)\n            if state ~= IndustryStatus.idle then -- no need to stop idle industry\n                system.print(\"--- stopping \" ..\n                industryname .. \" with state running:\" .. tostring(state == IndustryStatus.running))\n                y(f)\n                slot.stop(false, false)\n            end\n\n            y(f)\n            slot.setOutput(item.id)\n\n            -- ensure the output item is the wanted id\n            y(f)\n            local outputs = slot.getOutputs()\n            if outputs and outputs[1] and outputs[1].id == item.id then\n                y(f)\n                local toMaintain = mceil(item.quantity * maintainMultiplier) -- NB \"even if the transfer unit is drowning do not pass it a float\" -- BBDarth\n                system.print(industryname .. \" toMaintain \" .. toMaintain)\n\n                slot.startMaintain(toMaintain)\n                system.print(industryname .. \" maintaining \" .. getName(item.id) .. \" x\" .. toMaintain)\n\n                setKnown(industryname, item.id)\n                -- get the new status, e.g. do we need schematics?\n                y(f)\n                local info = slot.getInfo()\n                state = info.state\n                if state == IndustryStatus.running\n                    or state == IndustryStatus.pending\n                    or state == IndustryStatus.no_schemas then\n                    cooking[outputs[1].id] = true\n                end\n\n                if isATransferUnit(industryname) then\n                    -- some items, e.g. basic pipes, need at least 200 for transfers\n                    -- we need to let the other boards know this\n                    local inputs = slot.getInputs()\n                    if inputs[1].quantity > 1 then\n                        databank.setIntValue(\"transfer:\" .. item.id, mfloor(inputs[1].quantity))\n                    end\n                elseif unitname == \"chef\" and state == IndustryStatus.jammed then\n                    local inputs = slot.getInputs()\n                    local count = 0\n                    for _, input_item in pairs(inputs) do\n                        addNeed(input_item)\n                    end\n                end\n                -- make sure we're not cooking too many, sometimes a bug will put in way too many\n                checkForOverproducing(slot, info)\n            end\n        end\n    end\nend\n\nneedcount = 1\nneeds_added = {}\nfunction addNeed(item)\n    if needs_added[item.id] == true then return end\n    while databank.hasKey(\"needed\" .. needcount) == 1 and needcount < 30 do\n        needcount = needcount + 1\n    end\n    if needcount <= 30 then\n        databank.setStringValue(\"needed\" .. needcount, item.id)\n        system.print(needcount .. \" Need: \" .. item.id)\n        needs_added[item.id] = true\n    end\nend\n\nknown_industry = {}\nfunction getKnown(id)\n    local key = \"known:\" .. id\n    if known_industry[key] == nil or known_industry[key] == \"\" then\n        known_industry[key] = databank.getStringValue(key)\n    end\n    return known_industry[key]\nend\n\nslot_status_saved = {}\nfunction setKnown(industryname, id)\n    local key = \"known:\" .. id\n    if isNotATransferUnit(industryname) and slot_status_saved[key] == nil then\n        databank.setStringValue(key, industryname)\n        known_industry[key] = industryname\n        slot_status_saved[key] = true\n    end\nend\n\nnames = {}\nfunction getName(id)\n    if names[id] == nil then\n        names[id] = system.getItem(id).locDisplayNameWithSize\n    end\n    return names[id]\nend\n\npingkey = \"ping:\" .. unitName\nfunction ping()\n    databank.setIntValue(pingkey, mfloor(system.getArkTime()))\nend\n\n-- acutal execution starts here\n\ndatabank = nil\nindustries = {}\nstatus = {}\nstacks = {}\n\nfor slot_name, slot in pairs(unit) do\n    if type(slot) == \"table\" and type(slot.export) == \"table\" and slot.getClass then\n        slotClass = slot.getClass():lower()\n\n        if slotClass == 'databankunit' then\n            databank = slot\n        elseif slotClass:sub(0, 8) == \"industry\" then\n            slotId = slot.getLocalId()\n            industry = {\n                id = slotId,\n                slot = slot,\n                name = adjustIndustryName(slot.getName())\n            }\n            industries[slotId] = industry\n            -- table.insert(industries, industry)\n        end\n    end\nend\n\nunitname = unit.getName():lower()\nunitkey  = unitname:gsub(\"%d$\", \"\")\n\nfor id, industry in pairs(industries) do\n    databank.setStringValue(\"slot\" .. industry.id, unitName)\nend\n\ndatabank.setStringValue(unitname .. \"_version\", chef_linecook_version)\ndatabank.setStringValue(\"status:\" .. unitname, \"active\")\nout(\"INFO: \", unitname, \" is alive as type [\", unitkey, \"]\")\n\nlocal raw = databank.getStringValue(unitkey)\nif raw == \"\" then\n    out(\"ERROR: cannot find manager entry for [\", unitkey,\"]\")\n    return unit.exit()\nend\n\nfeed_multiplier = math.max(1.0, databank.getFloatValue(\"feed_multiplier\"))\nline_multiplier = math.max(1.0, databank.getFloatValue(\"line_multiplier\"))\nnum_lines = math.max(1, databank.getIntValue(\"num_lines\"))\n\nif num_lines <= 0 then\n    num_lines = 1\nelseif num_lines > 1 then\n    num_lines = mceil(num_lines / 1.25)\nend\nitems = deserialize(databank.getStringValue(unitkey))\nrequirements = {}\nlocal count = 0\nfor _, item in pairs(items) do\n    if unitkey == \"linecook\" then\n        local tu_quantity = databank.getIntValue(\"transfer:\" .. item.id)\n        tu_quantity = math.ceil(tu_quantity / num_lines)\n        if tu_quantity > item.quantity then\n            system.print(\"Transfer Unit upgrading \" ..\n                getName(item.id) .. \" from \" .. item.quantity .. \" to \" .. tu_quantity)\n            item.quantity = tu_quantity\n        end\n\n        -- some items we should never have more than a few of, such as catalysts\n        -- hardcode to restrict those item quantities\n        if item.id == 3729464848     -- catalyst 3\n            or item.id == 3729464849 -- catalyst 4\n            or item.id == 3729464850 -- catalyst 5\n        then\n            item.quantity = math.min(item.quantity, 5)\n        end\n    end\n\n    requirements[item.id] = item\n    count = count + 1\n    system.print(getName(item.id) .. \" x\" .. item.quantity)\nend\nif count == 0 then\n    system.print(\"0 items to build - exiting\")\n    unit.exit()\n    return\nend\n\nmaintainMultiplier = 1\nif unitkey == \"waitress\" then\n    maintainMultiplier = math.max(maintainMultiplier, feed_multiplier) * num_lines\nend\n\nlocal tickRatio = mceil((2.37 / 3.0)*100)/100\nlocal nextTickSeconds = tickRatio * num_lines\nunit.setTimer(\"next\", nextTickSeconds)\nunit.setTimer(\"ping\", 5)\n\n-- do not change the following\nnestco = {}\nfunction nestco:new(a)\n    local b = {}\n    setmetatable(b, self)\n    self.__index = self; b.functions = a or {}\n    b.coroutines = {}\n    function b.update() return b:_update() end; function b.init() return b:_init() end; function b.run() return b:_run() end; function b.update()\n        return\n            b:_update()\n    end; b.init()\n    b.main = coroutine.create(b.run)\n    return b\nend; function nestco:_init() for c, d in pairs(self.functions) do self.coroutines[c] = coroutine.create(d) end end; function nestco:_run()\n    for c, e in pairs(self.coroutines) do\n        local f = coroutine.status(e)\n        if f == \"dead\" then\n            self.coroutines[c] = coroutine.create(self.functions[c])\n        elseif f == \"suspended\" then\n            assert(\n                coroutine.resume(e))\n        end\n    end\nend; function nestco:_update()\n    local f = coroutine.status(self.main)\n    if f == \"dead\" then\n        self.main = coroutine.create(self.run)\n    elseif f == \"suspended\" then\n        assert(coroutine.resume(self\n            .main))\n    end\nend\n\nNestCo = nestco:new(functions)\nfunction y(f) coroutine.yield(f) end\n",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-1"
      },
      "key": "4"
    },
    {
      "code": "---- (1) ----\nlocal concat = table.concat\nlocal sFormat = string.format\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-5"
      },
      "key": "5"
    },
    {
      "code": "---- (2) ----\nfunction strSplit(a, b)\n    result = {}\n    for c in (a .. b):gmatch(\"(.-)\" .. b) do table.insert(result, c) end; return result\nend\n\nfunction strSplit(a,b)result={}for c in(a..b):gmatch(\"(.-)\"..b)do table.insert(result,c)end;return result end\n\nmfloor = math.floor\nmceil = math.ceil\nmmin = math.min\nmmax = math.max\nmrandom = math.random\nunitName = unit.getName()\n\nfunction clean(param)\n    if param == nil then return \" \" end\n    return param\nend\n\nfunction out(a, b, c, d)\n    system.print(clean(a) .. \" \" .. clean(b) .. \" \" .. clean(c) .. \" \" .. clean(d))\nend\n\nfunction newStack()\n    local o = {} o.entries = {} o.size = 0\n    o.push = function(object)\n        if object ~= nil then \n            o.size = o.size + 1\n            o.entries[o.size] = object\n        end\n    end\n    o.pop = function()\n        if o.size > 0 then\n            o.size = o.size - 1\n            return o.entries[o.size + 1]\n        end\n    end\n    return o\nend\n\nfunction shuffle(tbl)\n  for i = #tbl, 2, -1 do\n    local j = mrandom(i)\n    tbl[i], tbl[j] = tbl[j], tbl[i]\n  end\n  return tbl\nend\nmfloor   = math.floor\nmceil    = math.ceil\nmmin     = math.min\nmmax     = math.max\nmrandom  = math.random\nunitName = unit.getName()\n\nfunction newStack()\n    local o = {}\n    o.entries = {}\n    o.size = 0\n    o.push = function(object)\n        if object ~= nil then\n            o.size = o.size + 1\n            o.entries[o.size] = object\n        end\n    end\n    o.pop = function()\n        if o.size > 0 then\n            o.size = o.size - 1\n            return o.entries[o.size + 1]\n        end\n    end\n    return o\nend\n\nfunction shuffle(tbl)\n    for i = #tbl, 2, -1 do\n        local j = mrandom(i)\n        tbl[i], tbl[j] = tbl[j], tbl[i]\n    end\n    return tbl\nend\n",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-5"
      },
      "key": "6"
    },
    {
      "code": "---- (3) ----\nIndustryStatus\t= {}\nIndustryStatus.stopped\t\t= 1\nIndustryStatus.running\t\t= 2\nIndustryStatus.jammed\t\t= 3\nIndustryStatus.storage_full\t = 4\nIndustryStatus.bad_cfg\t\t= 5\nIndustryStatus.pending\t\t= 6\nIndustryStatus.no_schemas\t = 7\n\nfunction isATransferUnit(industryname)\n    local isATransferUnit = false\n    if industryname == \"unit l\" or \n        industryname == \"waitress\" then\n      isATransferUnit = true \n    end\n    return isATransferUnit\nend\n\nfunction isNotATransferUnit(industryname)\n    return (not isATransferUnit(industryname))\nend\n",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-5"
      },
      "key": "7"
    }
  ],
  "methods": [],
  "events": []
}